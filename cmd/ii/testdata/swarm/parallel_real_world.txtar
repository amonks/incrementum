# setup repo
mkdir repo
cd repo
exec jj git init
exec sh -c 'printf "%s\n" "[job]" "test-commands = [\"true\"]" > incrementum.toml'

# seed commits and main bookmark
exec sh -c 'printf "alpha\n" > app.txt'
exec jj describe -m 'feat: initial'
exec jj new
exec sh -c 'printf "beta\n" >> app.txt'
exec jj describe -m 'feat: update'
exec jj new
exec jj bookmark create main -r @-

# stub opencode
chmod 755 $WORK/bin/opencode
env PATH=$WORK/bin${:}$PATH

# create todos
exec $II todo create --title 'Swarm first' --description 'execute ''printf "swarm one" > swarm-one.txt''; take no other action'
exec $II todo create --title 'Swarm second' --description 'execute ''printf "swarm two" > swarm-two.txt''; take no other action'

exec $II todo list --json
todoid stdout 'Swarm first' TODO_ONE
todoid stdout 'Swarm second' TODO_TWO

# start swarm server
exec python3 -c 'import socket; s=socket.socket(); s.bind(("127.0.0.1", 0)); print(s.getsockname()[1]); s.close()'
envset SWARM_PORT stdout
exec $II swarm serve --addr 127.0.0.1:$SWARM_PORT &server&
stdin $WORK/wait_for_port.py
exec python3 -

# run swarm jobs in parallel
exec $II swarm do $TODO_ONE --addr 127.0.0.1:$SWARM_PORT &job_one&
exec $II swarm do $TODO_TWO --addr 127.0.0.1:$SWARM_PORT &job_two&
wait job_one
wait job_two

# verify todo status
exec $II todo show $TODO_ONE --json
stdout '"status": "done"'
exec $II todo show $TODO_TWO --json
stdout '"status": "done"'

# verify swarm job list
exec $II swarm list --addr 127.0.0.1:$SWARM_PORT --json
stdout '"status": "done"'

# verify main bookmark still points at seeded work
exec jj log -r main --no-graph
stdout '(?m)^feat: update$'

# verify swarm commits landed
exec jj log --no-graph
stdout '(?m)^feat: add swarm-one.txt$'
stdout '(?m)^feat: add swarm-two.txt$'

# verify swarm outputs landed on disk
exists swarm-one.txt
exists swarm-two.txt

-- wait_for_port.py --
import os
import socket
import time


port = int(os.environ["SWARM_PORT"])
deadline = time.time() + 5
while time.time() < deadline:
    sock = socket.socket()
    try:
        sock.connect(("127.0.0.1", port))
    except OSError:
        time.sleep(0.05)
        continue
    finally:
        sock.close()
    break
else:
    raise SystemExit("swarm server did not start")

-- bin/opencode --
#!/usr/bin/env python3

import http.server
import json
import os
import re
import subprocess
import sys
import time


def read_prompt(args):
    if not sys.stdin.isatty():
        prompt = sys.stdin.read()
        if prompt:
            return prompt
    if len(args) > 2 and not args[-1].startswith("--attach="):
        return args[-1]
    return ""


def extract_workspace_root(prompt: str) -> str:
    for line in prompt.splitlines():
        if line.startswith("Workspace root:"):
            return line.split(":", 1)[1].strip()
    return ""


def extract_command(prompt: str) -> str:
    match = re.search(r"execute '([^']+)'", prompt)
    if match:
        return match.group(1).strip()
    return ""


def commit_message_for_command(command: str) -> str:
    match = re.search(r">\s*([^\s]+)", command)
    if not match:
        return "feat: add swarm output\n"
    target = match.group(1).strip().strip('"')
    filename = os.path.basename(target)
    return f"feat: add {filename}\n"


def run_job(prompt: str):
    workspace_root = extract_workspace_root(prompt)
    pwd = os.environ.get("PWD", "")
    if not pwd:
        raise RuntimeError("PWD not set")
    if not workspace_root:
        workspace_root = pwd
    if os.path.realpath(pwd) != os.path.realpath(workspace_root):
        raise RuntimeError(f"PWD {pwd} does not match workspace root {workspace_root}")
    marker = os.path.join(workspace_root, ".incrementum-work-complete")
    if not os.path.exists(marker) and not prompt.startswith("Review"):
        command = extract_command(prompt)
        if command:
            subprocess.run(command, shell=True, cwd=workspace_root, check=True)
        else:
            open(os.path.join(workspace_root, "swarm-output.txt"), "a").close()
        message = commit_message_for_command(command)
        with open(os.path.join(workspace_root, ".incrementum-commit-message"), "w") as handle:
            handle.write(message)
        with open(marker, "w") as handle:
            handle.write("done")

    home = os.path.expanduser("~")
    storage_root = os.path.join(home, ".local", "share", "opencode", "storage")
    project_id = "proj_test"
    unique_suffix = f"{int(time.time() * 1000)}_{os.getpid()}"
    session_id = f"ses_{unique_suffix}"
    message_id = f"msg_{unique_suffix}"
    part_id = f"prt_{unique_suffix}"
    project_dir = os.path.join(storage_root, "project")
    session_dir = os.path.join(storage_root, "session", project_id)
    message_dir = os.path.join(storage_root, "message", session_id)
    part_dir = os.path.join(storage_root, "part", message_id)

    os.makedirs(project_dir, exist_ok=True)
    os.makedirs(session_dir, exist_ok=True)
    os.makedirs(message_dir, exist_ok=True)
    os.makedirs(part_dir, exist_ok=True)

    with open(os.path.join(project_dir, f"{project_id}.json"), "w") as handle:
        handle.write(f'{{"id":"{project_id}","worktree":"{workspace_root}"}}')

    created = int(time.time() * 1000)
    with open(os.path.join(session_dir, f"{session_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{session_id}","projectID":"{project_id}","directory":"{workspace_root}","time":{{"created":{created}}}}}'
        )

    with open(os.path.join(message_dir, f"{message_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{message_id}","sessionID":"{session_id}","role":"user","time":{{"created":{created}}}}}'
        )

    prompt_json = json.dumps(prompt)
    with open(os.path.join(part_dir, f"{part_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{part_id}","sessionID":"{session_id}","messageID":"{message_id}","type":"text","text":{prompt_json}}}'
        )


def run_serve(args):
    port = 0
    host = "localhost"
    for arg in args:
        if arg.startswith("--port="):
            port = int(arg.split("=", 1)[1])
            continue
        if arg.startswith("--hostname="):
            host = arg.split("=", 1)[1]
    if not port:
        return

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path != "/event":
                self.send_response(404)
                self.end_headers()
                return
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.end_headers()

        def log_message(self, *_args):
            return

    server = http.server.HTTPServer((host, port), Handler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        return


def main():
    if len(sys.argv) < 2:
        return
    cmd = sys.argv[1]
    if cmd == "run":
        prompt = read_prompt(sys.argv)
        run_job(prompt)
        return
    if cmd == "serve":
        run_serve(sys.argv[2:])
        return


if __name__ == "__main__":
    main()
