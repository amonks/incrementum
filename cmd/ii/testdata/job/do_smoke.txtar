# setup repo
mkdir repo
cd repo
exec jj git init

# stub opencode
chmod 755 $WORK/bin/opencode
env PATH=$WORK/bin${:}$PATH

# run job
exec env PWD=$WORK $II job do --title 'Touch file' --type task --priority 2 --description 'In the bash tool, run touch hello-world.txt' --no-edit
stdout 'Doing job [a-z0-9]+'
stdout 'Workdir: .+'
stdout 'Todo:'
stdout '    ID: [a-z0-9]+'
stdout '    Title: Touch file'
stdout '    Type: task'
stdout '    Priority: 2 \(medium\)'
stdout '    Description:'
stdout '        In the bash tool, run touch hello-world.txt'
stdout 'Running implementation prompt:'
stdout 'Implementation prompt complete; running tests:'
stdout 'Tests passed; doing code review:'
stdout 'Review complete; committing changes:'
stdout 'Running implementation prompt:'
stdout 'Implementation prompt complete; running tests:'
stdout 'Tests passed; doing code review:'
stdout 'Commit messages:'
stdout 'Test commit message'
stdout 'This commit is a step towards implementing this todo:'
exists hello-world.txt

-- bin/opencode --
#!/usr/bin/env python3

import http.server
import json
import os
import sys
import time

def read_prompt(args):
    if len(args) > 2 and not args[-1].startswith("--attach="):
        return args[-1]
    return sys.stdin.read()

def extract_workspace_root(prompt: str) -> str:
    for line in prompt.splitlines():
        if line.startswith("Workspace root:"):
            return line.split(":", 1)[1].strip()
    raise RuntimeError("workspace root missing from prompt")


def run_job(prompt: str):
    workspace_root = extract_workspace_root(prompt)
    pwd = os.environ.get("PWD", "")
    if not pwd:
        raise RuntimeError("PWD not set")
    if pwd != workspace_root:
        raise RuntimeError(f"PWD {pwd} does not match workspace root {workspace_root}")
    marker = os.path.join(workspace_root, ".incrementum-work-complete")
    if not os.path.exists(marker) and not prompt.startswith("Review"):
        open(os.path.join(workspace_root, "hello-world.txt"), "a").close()
        with open(os.path.join(workspace_root, ".incrementum-commit-message"), "w") as handle:
            handle.write("Test commit message\n")
        with open(marker, "w") as handle:
            handle.write("done")

    home = os.path.expanduser("~")
    storage_root = os.path.join(home, ".local", "share", "opencode", "storage")
    project_id = "proj_test"
    session_id = f"ses_{int(time.time() * 1000)}"
    message_id = f"msg_{session_id}"
    part_id = f"prt_{session_id}"
    project_dir = os.path.join(storage_root, "project")
    session_dir = os.path.join(storage_root, "session", project_id)
    message_dir = os.path.join(storage_root, "message", session_id)
    part_dir = os.path.join(storage_root, "part", message_id)

    os.makedirs(project_dir, exist_ok=True)
    os.makedirs(session_dir, exist_ok=True)
    os.makedirs(message_dir, exist_ok=True)
    os.makedirs(part_dir, exist_ok=True)

    with open(os.path.join(project_dir, f"{project_id}.json"), "w") as handle:
        handle.write(f'{{"id":"{project_id}","worktree":"{workspace_root}"}}')

    created = int(time.time() * 1000)
    with open(os.path.join(session_dir, f"{session_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{session_id}","projectID":"{project_id}","directory":"{workspace_root}","time":{{"created":{created}}}}}'
        )

    with open(os.path.join(message_dir, f"{message_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{message_id}","sessionID":"{session_id}","role":"user","time":{{"created":{created}}}}}'
        )

    prompt_json = json.dumps(prompt)
    with open(os.path.join(part_dir, f"{part_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{part_id}","sessionID":"{session_id}","messageID":"{message_id}","type":"text","text":{prompt_json}}}'
        )


def run_serve(args):
    port = 0
    host = "localhost"
    for arg in args:
        if arg.startswith("--port="):
            port = int(arg.split("=", 1)[1])
            continue
        if arg.startswith("--hostname="):
            host = arg.split("=", 1)[1]
    if not port:
        return

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path != "/event":
                self.send_response(404)
                self.end_headers()
                return
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.end_headers()

        def log_message(self, *_args):
            return

    server = http.server.HTTPServer((host, port), Handler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        return


def main():
    if len(sys.argv) < 2:
        return
    cmd = sys.argv[1]
    if cmd == "run":
        prompt = read_prompt(sys.argv)
        run_job(prompt)
        return
    if cmd == "serve":
        run_serve(sys.argv[2:])
        return


if __name__ == "__main__":
    main()
