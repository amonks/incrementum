# setup repo
mkdir repo
cd repo
exec jj git init
exec sh -c 'printf "%s\n" "[job]" "test-commands = [\"true\"]" > incrementum.toml'

# stub opencode
chmod 755 $WORK/bin/opencode
env PATH=$WORK/bin${:}$PATH

# create todos
exec $II todo create --title 'P0 Bug' --type bug --priority 0 --description 'P0 bug' --no-edit
exec $II todo create --title 'P1 Bug' --type bug --priority 1 --description 'P1 bug' --no-edit
exec $II todo create --title 'P2 Bug' --type bug --priority 2 --description 'P2 bug' --no-edit
exec $II todo create --title 'P1 Task' --type task --priority 1 --description 'P1 task' --no-edit

# run filtered do-all
exec env PWD=$WORK $II job do-all --priority=1 --type=bug
stdout 'Title: P0 Bug'
stdout 'Title: P1 Bug'
stdout 'nothing left to do'

# verify statuses
exec sh -c '$II todo list --status done --json > done.json'
todoid done.json 'P0 Bug' P0_ID
todoid done.json 'P1 Bug' P1_ID
exec sh -c '$II todo list --status open --json > open.json'
todoid open.json 'P2 Bug' P2_ID
todoid open.json 'P1 Task' P1_TASK_ID

-- bin/opencode --
#!/usr/bin/env python3

import http.server
import json
import os
import sys
import time

def read_prompt(args):
    if not sys.stdin.isatty():
        prompt = sys.stdin.read()
        if prompt:
            return prompt
    if len(args) > 2 and not args[-1].startswith("--attach="):
        return args[-1]
    return ""

def extract_todo_id(prompt: str) -> str:
    for line in prompt.splitlines():
        line = line.strip()
        if line.startswith("ID:"):
            return line.split(":", 1)[1].strip()
    return "unknown"

def run_job(prompt: str):
    pwd = os.environ.get("PWD", "")
    if not pwd:
        raise RuntimeError("PWD not set")
    workspace_root = pwd

    todo_id = extract_todo_id(prompt)
    marker = os.path.join(workspace_root, f".incrementum-work-complete-{todo_id}")
    if not prompt.startswith("Review") and not os.path.exists(marker):
        open(os.path.join(workspace_root, f"todo-{todo_id}.txt"), "a").close()
        with open(os.path.join(workspace_root, ".incrementum-commit-message"), "w") as handle:
            handle.write(f"Test commit message for {todo_id}\n")
        with open(marker, "w") as handle:
            handle.write("done")

    home = os.path.expanduser("~")
    storage_root = os.path.join(home, ".local", "share", "opencode", "storage")
    project_id = "proj_test"
    session_id = f"ses_{int(time.time() * 1000)}"
    message_id = f"msg_{session_id}"
    part_id = f"prt_{session_id}"
    project_dir = os.path.join(storage_root, "project")
    session_dir = os.path.join(storage_root, "session", project_id)
    message_dir = os.path.join(storage_root, "message", session_id)
    part_dir = os.path.join(storage_root, "part", message_id)

    os.makedirs(project_dir, exist_ok=True)
    os.makedirs(session_dir, exist_ok=True)
    os.makedirs(message_dir, exist_ok=True)
    os.makedirs(part_dir, exist_ok=True)

    with open(os.path.join(project_dir, f"{project_id}.json"), "w") as handle:
        handle.write(f'{{"id":"{project_id}","worktree":"{workspace_root}"}}')

    created = int(time.time() * 1000)
    with open(os.path.join(session_dir, f"{session_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{session_id}","projectID":"{project_id}","directory":"{workspace_root}","time":{{"created":{created}}}}}'
        )

    with open(os.path.join(message_dir, f"{message_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{message_id}","sessionID":"{session_id}","role":"user","time":{{"created":{created}}}}}'
        )

    prompt_json = json.dumps(prompt)
    with open(os.path.join(part_dir, f"{part_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{part_id}","sessionID":"{session_id}","messageID":"{message_id}","type":"text","text":{prompt_json}}}'
        )

def run_serve(args):
    port = 0
    host = "localhost"
    for arg in args:
        if arg.startswith("--port="):
            port = int(arg.split("=", 1)[1])
            continue
        if arg.startswith("--hostname="):
            host = arg.split("=", 1)[1]
    if not port:
        return

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path != "/event":
                self.send_response(404)
                self.end_headers()
                return
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.end_headers()

        def log_message(self, *_args):
            return

    server = http.server.HTTPServer((host, port), Handler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        return

def main():
    if len(sys.argv) < 2:
        return
    cmd = sys.argv[1]
    if cmd == "run":
        prompt = read_prompt(sys.argv)
        run_job(prompt)
        return
    if cmd == "serve":
        run_serve(sys.argv[2:])
        return

if __name__ == "__main__":
    main()
