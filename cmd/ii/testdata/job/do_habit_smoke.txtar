# Test ii job do --habit runs the habit workflow
# This test verifies the basic habit workflow:
# 1. --habit flag loads habit from .incrementum/habits/
# 2. Uses habit-specific prompt template
# 3. Creates artifact todo on success with source:habit:<name>

# setup repo
mkdir repo
cd repo
exec jj git init
exec sh -c 'printf "%s\n" "[job]" "test-commands = [\"true\"]" > incrementum.toml'

# create habit file
mkdir -p .incrementum/habits
cp $WORK/cleanup.md .incrementum/habits/cleanup.md

# stub opencode
chmod 755 $WORK/bin/opencode
env PATH=$WORK/bin${:}$PATH

# run habit job (no name = first habit alphabetically)
exec env PWD=$WORK $II job do --habit
stdout 'Doing habit job [a-z0-9]+'
stdout 'Workdir: .+'
stdout 'Habit: cleanup'
stdout 'Running implementation prompt:'
stdout 'Implementation prompt complete; running tests:'
stdout 'Starting review:'
stdout 'Review complete; committing changes:'
stdout 'Created artifact todo:'
stdout 'Title: Fix unused variable'

# verify artifact todo was created with correct source and timestamps
exec sh -c '$II todo list --status done --json > done.json'
todoid done.json 'Fix unused variable' ARTIFACT_ID
# Check source field in JSON output (using regex that handles whitespace)
grep 'habit:cleanup' done.json
# Verify started_at is set on the artifact (per spec, should be creation time)
grep 'started_at' done.json

-- cleanup.md --
# Cleanup Habit

Look for code cleanup opportunities.

## Guidelines

- Remove dead code
- Fix unused variables
- Simplify complex logic

-- bin/opencode --
#!/usr/bin/env python3

import http.server
import json
import os
import sys
import time

def read_prompt(args):
    if not sys.stdin.isatty():
        prompt = sys.stdin.read()
        if prompt:
            return prompt
    if len(args) > 2 and not args[-1].startswith("--attach="):
        return args[-1]
    return ""

def run_job(prompt: str):
    pwd = os.environ.get("PWD", "")
    if not pwd:
        raise RuntimeError("PWD not set")
    workspace_root = pwd
    marker = os.path.join(workspace_root, ".incrementum-habit-work-complete")
    if not os.path.exists(marker) and not prompt.startswith("Review"):
        # Simulate making changes
        open(os.path.join(workspace_root, "cleanup-fix.txt"), "a").close()
        with open(os.path.join(workspace_root, ".incrementum-commit-message"), "w") as handle:
            handle.write("Fix unused variable\n\nRemoved unused variable in main.go\n")
        with open(marker, "w") as handle:
            handle.write("done")

    home = os.path.expanduser("~")
    storage_root = os.path.join(home, ".local", "share", "opencode", "storage")
    project_id = "proj_test"
    session_id = f"ses_{int(time.time() * 1000)}"
    message_id = f"msg_{session_id}"
    part_id = f"prt_{session_id}"
    project_dir = os.path.join(storage_root, "project")
    session_dir = os.path.join(storage_root, "session", project_id)
    message_dir = os.path.join(storage_root, "message", session_id)
    part_dir = os.path.join(storage_root, "part", message_id)

    os.makedirs(project_dir, exist_ok=True)
    os.makedirs(session_dir, exist_ok=True)
    os.makedirs(message_dir, exist_ok=True)
    os.makedirs(part_dir, exist_ok=True)

    with open(os.path.join(project_dir, f"{project_id}.json"), "w") as handle:
        handle.write(f'{{"id":"{project_id}","worktree":"{workspace_root}"}}')

    created = int(time.time() * 1000)
    with open(os.path.join(session_dir, f"{session_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{session_id}","projectID":"{project_id}","directory":"{workspace_root}","time":{{"created":{created}}}}}'
        )

    with open(os.path.join(message_dir, f"{message_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{message_id}","sessionID":"{session_id}","role":"user","time":{{"created":{created}}}}}'
        )

    prompt_json = json.dumps(prompt)
    with open(os.path.join(part_dir, f"{part_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{part_id}","sessionID":"{session_id}","messageID":"{message_id}","type":"text","text":{prompt_json}}}'
        )


def run_serve(args):
    port = 0
    host = "localhost"
    for arg in args:
        if arg.startswith("--port="):
            port = int(arg.split("=", 1)[1])
            continue
        if arg.startswith("--hostname="):
            host = arg.split("=", 1)[1]
    if not port:
        return

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path != "/event":
                self.send_response(404)
                self.end_headers()
                return
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.end_headers()

        def log_message(self, *_args):
            return

    server = http.server.HTTPServer((host, port), Handler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        return


def main():
    if len(sys.argv) < 2:
        return
    cmd = sys.argv[1]
    if cmd == "run":
        prompt = read_prompt(sys.argv)
        run_job(prompt)
        return
    if cmd == "serve":
        run_serve(sys.argv[2:])
        return


if __name__ == "__main__":
    main()
