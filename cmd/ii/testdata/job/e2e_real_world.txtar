# setup repo
mkdir repo
cd repo
exec jj git init

# seed commits and main bookmark
exec sh -c 'printf "alpha\n" > app.txt'
exec jj describe -m 'feat: initial'
exec jj new
exec sh -c 'printf "beta\n" >> app.txt'
exec jj describe -m 'feat: update'
exec jj new
exec jj bookmark create main -r @-

# stub opencode
chmod 755 $WORK/bin/opencode
env PATH=$WORK/bin${:}$PATH

# create todo
exec $II todo create --title 'Add job output' --description 'execute ''printf "job output" > job-output.txt''; take no other action'
stdout 'Created todo'

exec $II todo list --json
todoid stdout 'Add job output' TODO_ID

# run job
exec $II job do $TODO_ID
stdout 'Doing job'
exists job-output.txt

# verify todo status
exec $II todo show $TODO_ID --json
stdout '"status": "done"'

# verify main bookmark still points at seeded work
exec jj log -r main --no-graph
stdout '(?m)^feat: update$'

# verify job commit landed
exec jj log -r @- --no-graph
stdout '(?m)^feat: add job-output.txt$'

-- bin/opencode --
#!/usr/bin/env python3

import http.server
import json
import os
import re
import subprocess
import sys
import time


def read_prompt(args):
    if not sys.stdin.isatty():
        prompt = sys.stdin.read()
        if prompt:
            return prompt
    if len(args) > 2 and not args[-1].startswith("--attach="):
        return args[-1]
    return ""


def extract_workspace_root(prompt: str) -> str:
    for line in prompt.splitlines():
        if line.startswith("Workspace root:"):
            return line.split(":", 1)[1].strip()
    return ""


def extract_command(prompt: str) -> str:
    match = re.search(r"execute '([^']+)'", prompt)
    if match:
        return match.group(1).strip()
    return ""


def commit_message_for_command(command: str) -> str:
    match = re.search(r">\s*([^\s]+)", command)
    if not match:
        return "feat: add job output\n"
    target = match.group(1).strip().strip('"')
    filename = os.path.basename(target)
    return f"feat: add {filename}\n"


def run_job(prompt: str):
    workspace_root = extract_workspace_root(prompt)
    pwd = os.environ.get("PWD", "")
    if not pwd:
        raise RuntimeError("PWD not set")
    if not workspace_root:
        workspace_root = pwd
    if os.path.realpath(pwd) != os.path.realpath(workspace_root):
        raise RuntimeError(f"PWD {pwd} does not match workspace root {workspace_root}")
    marker = os.path.join(workspace_root, ".incrementum-work-complete")
    if not os.path.exists(marker) and not prompt.startswith("Review"):
        command = extract_command(prompt)
        if command:
            subprocess.run(command, shell=True, cwd=workspace_root, check=True)
        else:
            open(os.path.join(workspace_root, "job-output.txt"), "a").close()
        message = commit_message_for_command(command)
        with open(os.path.join(workspace_root, ".incrementum-commit-message"), "w") as handle:
            handle.write(message)
        with open(marker, "w") as handle:
            handle.write("done")

    home = os.path.expanduser("~")
    storage_root = os.path.join(home, ".local", "share", "opencode", "storage")
    project_id = "proj_test"
    unique_suffix = f"{int(time.time() * 1000)}_{os.getpid()}"
    session_id = f"ses_{unique_suffix}"
    message_id = f"msg_{unique_suffix}"
    part_id = f"prt_{unique_suffix}"
    project_dir = os.path.join(storage_root, "project")
    session_dir = os.path.join(storage_root, "session", project_id)
    message_dir = os.path.join(storage_root, "message", session_id)
    part_dir = os.path.join(storage_root, "part", message_id)

    os.makedirs(project_dir, exist_ok=True)
    os.makedirs(session_dir, exist_ok=True)
    os.makedirs(message_dir, exist_ok=True)
    os.makedirs(part_dir, exist_ok=True)

    with open(os.path.join(project_dir, f"{project_id}.json"), "w") as handle:
        handle.write(f'{{"id":"{project_id}","worktree":"{workspace_root}"}}')

    created = int(time.time() * 1000)
    with open(os.path.join(session_dir, f"{session_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{session_id}","projectID":"{project_id}","directory":"{workspace_root}","time":{{"created":{created}}}}}'
        )

    with open(os.path.join(message_dir, f"{message_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{message_id}","sessionID":"{session_id}","role":"user","time":{{"created":{created}}}}}'
        )

    prompt_json = json.dumps(prompt)
    with open(os.path.join(part_dir, f"{part_id}.json"), "w") as handle:
        handle.write(
            f'{{"id":"{part_id}","sessionID":"{session_id}","messageID":"{message_id}","type":"text","text":{prompt_json}}}'
        )


def run_serve(args):
    port = 0
    host = "localhost"
    for arg in args:
        if arg.startswith("--port="):
            port = int(arg.split("=", 1)[1])
            continue
        if arg.startswith("--hostname="):
            host = arg.split("=", 1)[1]
    if not port:
        return

    class Handler(http.server.BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path != "/event":
                self.send_response(404)
                self.end_headers()
                return
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.end_headers()

        def log_message(self, *_args):
            return

    server = http.server.HTTPServer((host, port), Handler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        return


def main():
    if len(sys.argv) < 2:
        return
    cmd = sys.argv[1]
    if cmd == "run":
        prompt = read_prompt(sys.argv)
        run_job(prompt)
        return
    if cmd == "serve":
        run_serve(sys.argv[2:])
        return


if __name__ == "__main__":
    main()
